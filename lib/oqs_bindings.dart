// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
@ffi.DefaultAsset('qrypt')
library;

import 'dart:ffi' as ffi;

@ffi.Native<ffi.Pointer<OQS_KEM> Function()>()
external ffi.Pointer<OQS_KEM> OQS_KEM_kyber_512_new();

/// Frees an OQS_KEM object that was constructed by OQS_KEM_new.
///
/// @param[in] kem The OQS_KEM object to free.
@ffi.Native<ffi.Void Function(ffi.Pointer<OQS_KEM>)>()
external void OQS_KEM_free(
  ffi.Pointer<OQS_KEM> kem,
);

/// Represents return values from functions.
///
/// Callers should compare with the symbol rather than the individual value.
/// For example,
///
/// ret = OQS_KEM_encaps(...);
/// if (ret == OQS_SUCCESS) { ... }
///
/// rather than
///
/// if (!OQS_KEM_encaps(...) { ... }
enum OQS_STATUS {
  /// Used to indicate that some undefined error occurred.
  OQS_ERROR(-1),

  /// Used to indicate successful return from function.
  OQS_SUCCESS(0),

  /// Used to indicate failures in external libraries (e.g., OpenSSL).
  OQS_EXTERNAL_LIB_ERROR_OPENSSL(50);

  final int value;
  const OQS_STATUS(this.value);

  static OQS_STATUS fromValue(int value) => switch (value) {
        -1 => OQS_ERROR,
        0 => OQS_SUCCESS,
        50 => OQS_EXTERNAL_LIB_ERROR_OPENSSL,
        _ => throw ArgumentError('Unknown value for OQS_STATUS: $value'),
      };
}

/// Key encapsulation mechanism object
final class OQS_KEM extends ffi.Struct {
  /// Printable string representing the name of the key encapsulation mechanism.
  external ffi.Pointer<ffi.Char> method_name;

  /// Printable string representing the version of the cryptographic algorithm.
  ///
  /// Implementations with the same method_name and same alg_version will be interoperable.
  /// See README.md for information about algorithm compatibility.
  external ffi.Pointer<ffi.Char> alg_version;

  /// The NIST security level (1, 2, 3, 4, 5) claimed in this algorithm's original NIST submission.
  @ffi.Uint8()
  external int claimed_nist_level;

  /// Whether the KEM offers IND-CCA security (TRUE) or IND-CPA security (FALSE).
  @ffi.Bool()
  external bool ind_cca;

  /// The length, in bytes, of public keys for this KEM.
  @ffi.Size()
  external int length_public_key;

  /// The length, in bytes, of secret keys for this KEM.
  @ffi.Size()
  external int length_secret_key;

  /// The length, in bytes, of ciphertexts for this KEM.
  @ffi.Size()
  external int length_ciphertext;

  /// The length, in bytes, of shared secrets for this KEM.
  @ffi.Size()
  external int length_shared_secret;

  /// The length, in bytes, of seeds for derandomized keypair generation for this KEM.
  @ffi.Size()
  external int length_keypair_seed;

  /// Derandomized keypair generation algorithm.
  ///
  /// Caller is responsible for allocating sufficient memory for `public_key` and
  /// `secret_key`, based on the `length_*` members in this object or the per-scheme
  /// compile-time macros `OQS_KEM_*_length_*`.
  ///
  /// @param[out] public_key The public key represented as a byte string.
  /// @param[out] secret_key The secret key represented as a byte string.
  /// @param[in] seed The input randomness represented as a byte string.
  /// @return OQS_SUCCESS or OQS_ERROR
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Uint8> public_key,
              ffi.Pointer<ffi.Uint8> secret_key,
              ffi.Pointer<ffi.Uint8> seed)>> keypair_derand;

  /// Keypair generation algorithm.
  ///
  /// Caller is responsible for allocating sufficient memory for `public_key` and
  /// `secret_key`, based on the `length_*` members in this object or the per-scheme
  /// compile-time macros `OQS_KEM_*_length_*`.
  ///
  /// @param[out] public_key The public key represented as a byte string.
  /// @param[out] secret_key The secret key represented as a byte string.
  /// @return OQS_SUCCESS or OQS_ERROR
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Uint8> public_key,
              ffi.Pointer<ffi.Uint8> secret_key)>> keypair;

  /// Encapsulation algorithm.
  ///
  /// Caller is responsible for allocating sufficient memory for `ciphertext` and
  /// `shared_secret`, based on the `length_*` members in this object or the per-scheme
  /// compile-time macros `OQS_KEM_*_length_*`.
  ///
  /// @param[out] ciphertext The ciphertext (encapsulation) represented as a byte string.
  /// @param[out] shared_secret The shared secret represented as a byte string.
  /// @param[in] public_key The public key represented as a byte string.
  /// @return OQS_SUCCESS or OQS_ERROR
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Uint8> ciphertext,
              ffi.Pointer<ffi.Uint8> shared_secret,
              ffi.Pointer<ffi.Uint8> public_key)>> encaps;

  /// Decapsulation algorithm.
  ///
  /// Caller is responsible for allocating sufficient memory for `shared_secret`, based
  /// on the `length_*` members in this object or the per-scheme compile-time macros
  /// `OQS_KEM_*_length_*`.
  ///
  /// @param[out] shared_secret The shared secret represented as a byte string.
  /// @param[in] ciphertext The ciphertext (encapsulation) represented as a byte string.
  /// @param[in] secret_key The secret key represented as a byte string.
  /// @return OQS_SUCCESS or OQS_ERROR
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Uint8> shared_secret,
              ffi.Pointer<ffi.Uint8> ciphertext,
              ffi.Pointer<ffi.Uint8> secret_key)>> decaps;
}
